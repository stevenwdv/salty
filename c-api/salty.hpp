#ifndef salty_h
#define salty_h

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <cstdarg>
#include <cstdint>
#include <cstdlib>
#include <new>

static const uintptr_t salty_COMPRESSED_Y_LENGTH = 32;
static const uintptr_t salty_PUBLICKEY_SERIALIZED_LENGTH = 32;
static const uintptr_t salty_FIELD_ELEMENT_LENGTH = 32;
static const uintptr_t salty_SCALAR_LENGTH = 32;
static const uintptr_t salty_SECRETKEY_NONCE_LENGTH = 32;
static const uintptr_t salty_SECRETKEY_SCALAR_LENGTH = 32;
static const uintptr_t salty_SECRETKEY_SEED_LENGTH = 32;
static const uintptr_t salty_SECRETKEY_SERIALIZED_LENGTH = 32;
static const uintptr_t salty_SHA256_LENGTH = 64;
static const uintptr_t salty_SHA512_LENGTH = 64;
static const uintptr_t salty_SIGNATURE_SERIALIZED_LENGTH = 64;

/// Extensible error type for all `salty` operations.
///
/// This enum has a hidden member, to prevent exhaustively checking for errors.
/// It also has a member `NoError` with value zero, for use in the C API.
enum class salty_Error {
  /// Never occurs, simplifies C bindings
  NoError = 0,
  /// Bytes do not correspond to a canonical base field element
  NonCanonicalFieldElement,
  /// Public key bytes invalid
  PublicKeyBytesInvalid,
  /// Signature verification failed
  SignatureInvalid,
  /// Context for prehashed signatures too long
  ContextTooLong,
  /// Point is on other twist of curve
  WrongTwist,
  _Extensible,
};

extern "C" {

/// Generates a public key from a secret seed. Use to verify signatures.
void salty_public_key(const uint8_t (*seed)[salty_SECRETKEY_SEED_LENGTH],
                      uint8_t (*public_key)[salty_PUBLICKEY_SERIALIZED_LENGTH]);

/// Signs the data, based on the keypair generated from the secret seed.
void salty_sign(const uint8_t (*seed)[salty_SECRETKEY_SEED_LENGTH],
                const uint8_t *data_ptr,
                uintptr_t data_len,
                uint8_t (*signature)[salty_SIGNATURE_SERIALIZED_LENGTH]);

void salty_sign_get_first_hash_init_data(const uint8_t (*seed)[salty_SECRETKEY_SEED_LENGTH],
                                         uint8_t (*first_hash_init)[salty_SECRETKEY_NONCE_LENGTH]);

void salty_sign_get_second_hash_init_data(const uint8_t (*seed)[salty_SECRETKEY_SEED_LENGTH],
                                          const uint8_t (*first_hash)[salty_SHA512_LENGTH],
                                          uint8_t (*second_hash_init)[64],
                                          uint8_t (*secret_r)[salty_SCALAR_LENGTH]);

void salty_sign_finalize(const uint8_t (*seed)[salty_SECRETKEY_SEED_LENGTH],
                         const uint8_t (*second_hash)[salty_SHA512_LENGTH],
                         const uint8_t (*secret_r)[salty_SCALAR_LENGTH],
                         uint8_t (*signature)[salty_SIGNATURE_SERIALIZED_LENGTH]);

/// Signs the data for a given context, based on the keypair generated
/// from the secret seed.
salty_Error salty_sign_with_context(const uint8_t (*seed)[salty_SECRETKEY_SEED_LENGTH],
                                    const uint8_t *data_ptr,
                                    uintptr_t data_len,
                                    const uint8_t *context_ptr,
                                    uintptr_t context_len,
                                    uint8_t (*signature)[salty_SIGNATURE_SERIALIZED_LENGTH]);

/// Signs the prehashed data, based on the keypair generated from the secret seed.
/// An optional context can also be passed (this is recommended).
salty_Error salty_sign_prehashed(const uint8_t (*seed)[salty_SECRETKEY_SEED_LENGTH],
                                 const uint8_t (*prehashed_data)[salty_SHA512_LENGTH],
                                 const uint8_t *context_ptr,
                                 uintptr_t context_len,
                                 uint8_t (*signature)[salty_SIGNATURE_SERIALIZED_LENGTH]);

/// Verify a presumed signature on the given data.
salty_Error salty_verify(const uint8_t (*public_key)[salty_PUBLICKEY_SERIALIZED_LENGTH],
                         const uint8_t *data_ptr,
                         uintptr_t data_len,
                         const uint8_t (*signature)[salty_SIGNATURE_SERIALIZED_LENGTH]);

/// Verify a presumed signature on the given data.
salty_Error salty_verify_with_context(const uint8_t (*public_key)[salty_PUBLICKEY_SERIALIZED_LENGTH],
                                      const uint8_t *data_ptr,
                                      uintptr_t data_len,
                                      const uint8_t (*signature)[salty_SIGNATURE_SERIALIZED_LENGTH],
                                      const uint8_t *context_ptr,
                                      uintptr_t context_len);

/// Verify a presumed signature on the given data.
salty_Error salty_verify_prehashed(const uint8_t (*public_key)[salty_PUBLICKEY_SERIALIZED_LENGTH],
                                   const uint8_t (*prehashed_data)[salty_SHA512_LENGTH],
                                   const uint8_t (*signature)[salty_SIGNATURE_SERIALIZED_LENGTH],
                                   const uint8_t *context_ptr,
                                   uintptr_t context_len);

/// Perform X25519 key agreement.
void salty_agree(const uint8_t (*scalar)[salty_SECRETKEY_SEED_LENGTH],
                 const uint8_t (*input_u)[salty_FIELD_ELEMENT_LENGTH],
                 uint8_t (*output_u)[salty_FIELD_ELEMENT_LENGTH]);

} // extern "C"

#endif // salty_h
